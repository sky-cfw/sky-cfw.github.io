<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="OAuth2.0解决什么问题？OAuth2.0：Open Authenticate 即开放认证2.0协议，本质上是一种授权机制，解决的是安全授权第三方应用获取用户数据的问题。 数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 OAuth2.0是怎么保证安全性的？—要理解OAuth2.0就必须先理解以下几个">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/10/12/%E7%90%86%E8%A7%A3OAuth2.0%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="OAuth2.0解决什么问题？OAuth2.0：Open Authenticate 即开放认证2.0协议，本质上是一种授权机制，解决的是安全授权第三方应用获取用户数据的问题。 数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 OAuth2.0是怎么保证安全性的？—要理解OAuth2.0就必须先理解以下几个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="evernotecid://182EBBDA-58B1-4D0E-8473-358C52270E1E/appyinxiangcom/10870108/ENResource/p939">
<meta property="article:published_time" content="2021-10-12T15:07:38.000Z">
<meta property="article:modified_time" content="2021-10-12T15:21:32.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="evernotecid://182EBBDA-58B1-4D0E-8473-358C52270E1E/appyinxiangcom/10870108/ENResource/p939">


<link rel="canonical" href="http://example.com/2021/10/12/%E7%90%86%E8%A7%A3OAuth2.0%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/10/12/%E7%90%86%E8%A7%A3OAuth2.0%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6/","path":"2021/10/12/理解OAuth2.0授权机制/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | Hexo</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?eff1fb0f0bdccce601211ebfd244412d# <app_id>"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#OAuth2-0%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">OAuth2.0解决什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OAuth2-0%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">OAuth2.0是怎么保证安全性的？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OAuth2-0%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%843%E4%B8%AA%E8%A7%92%E8%89%B2"><span class="nav-number">2.1.</span> <span class="nav-text">OAuth2.0涉及到的3个角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#access-token"><span class="nav-number">2.2.</span> <span class="nav-text">access_token</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OAuth2-0%E8%8E%B7%E5%8F%96%E4%BB%A4%E7%89%8C-access-token-%E7%9A%844%E7%A7%8D%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">OAuth2.0获取令牌(access_token)的4种授权机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%88%E6%9D%83%E7%A0%81-authorization-code"><span class="nav-number">3.1.</span> <span class="nav-text">授权码(authorization code)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">隐藏式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">密码式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%AD%E8%AF%81%E5%BC%8F"><span class="nav-number">3.4.</span> <span class="nav-text">凭证式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A4%E7%89%8C%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">令牌的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A4%E7%89%8C%E7%9A%84%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">令牌的更新机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD"><span class="nav-number">7.</span> <span class="nav-text">术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#scope%E6%8E%88%E6%9D%83%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">7.1.</span> <span class="nav-text">scope授权作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%88%E6%9D%83%E4%B8%B4%E6%97%B6%E7%A5%A8%E6%8D%AE-code"><span class="nav-number">7.2.</span> <span class="nav-text">授权临时票据 code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E5%87%AD%E8%AF%81-access-token"><span class="nav-number">7.3.</span> <span class="nav-text">接口调用凭证 access_token</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#refresh-token"><span class="nav-number">7.4.</span> <span class="nav-text">refresh_token</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q-amp-A"><span class="nav-number">8.</span> <span class="nav-text">Q &amp; A</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WQ-%E7%9A%84-%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A5%E5%8F%A3-access-token-%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8A%A4%E7%9A%84%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%98%AF%E4%BD%A0%E5%81%9A%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E7%BB%B4%E6%8A%A4%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">WQ 的 公众号接口 access_token 是如何维护的？如果是你做，你会怎么维护？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E5%B9%B3%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E6%80%81%E6%A0%A1%E9%AA%8C-openid-%E5%92%8C-openkey-%E8%B0%83%E7%94%A8%E7%9A%84%E6%98%AF%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A0%A1%E9%AA%8C%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E5%87%AD%E8%AF%81%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">计平的微信登录态校验 openid 和 openkey 调用的是微信开放平台提供的校验接口调用凭证是否有效的接口？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">9.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/12/%E7%90%86%E8%A7%A3OAuth2.0%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-12 23:07:38 / 修改时间：23:21:32" itemprop="dateCreated datePublished" datetime="2021-10-12T23:07:38+08:00">2021-10-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="OAuth2-0解决什么问题？"><a href="#OAuth2-0解决什么问题？" class="headerlink" title="OAuth2.0解决什么问题？"></a>OAuth2.0解决什么问题？</h3><p>OAuth2.0：<code>Open Authenticate</code> 即开放认证2.0协议，本质上是一种授权机制，解决的是安全授权第三方应用获取用户数据的问题。</p>
<p>数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p>
<h3 id="OAuth2-0是怎么保证安全性的？"><a href="#OAuth2-0是怎么保证安全性的？" class="headerlink" title="OAuth2.0是怎么保证安全性的？"></a>OAuth2.0是怎么保证安全性的？</h3><p>—要理解OAuth2.0就必须先理解以下几个概念</p>
<h4 id="OAuth2-0涉及到的3个角色"><a href="#OAuth2-0涉及到的3个角色" class="headerlink" title="OAuth2.0涉及到的3个角色"></a>OAuth2.0涉及到的3个角色</h4><ul>
<li><strong>资源所有用</strong></li>
</ul>
<p>指用户本人</p>
<ul>
<li><strong>资源服务器</strong></li>
</ul>
<p>指存储用户数据的网络服务</p>
<ul>
<li><strong>第三方应用</strong></li>
</ul>
<h4 id="access-token"><a href="#access-token" class="headerlink" title="access_token"></a>access_token</h4><p><code>access_token</code>可理解为令牌，与密码的作用是一样的，都可以进入系统，但是有3点差异：</p>
<ul>
<li><p>令牌是短期的，到期自动失效；</p>
</li>
<li><p>令牌可以被数据所有者随时撤销；</p>
</li>
<li><p>令牌有权限范围(scope)</p>
</li>
</ul>
<p><code>access_token</code>的上述3个特性，在让第三方应用获取用户数据的同时，也保证了数据的安全性。</p>
<p>注意只要知道了access_token就能进入系统，泄漏access_token与泄漏密码的后果是一致的。所以access_token的有效期一般都设置的很短。</p>
<h3 id="OAuth2-0获取令牌-access-token-的4种授权机制"><a href="#OAuth2-0获取令牌-access-token-的4种授权机制" class="headerlink" title="OAuth2.0获取令牌(access_token)的4种授权机制"></a>OAuth2.0获取令牌(access_token)的4种授权机制</h3><h4 id="授权码-authorization-code"><a href="#授权码-authorization-code" class="headerlink" title="授权码(authorization code)"></a>授权码(authorization code)</h4><ul>
<li>指第三方应用先申请一个<code>authorization code</code>，然后再用该码获取<code>access_token</code>,流程如下：</li>
</ul>
<p>![image-20211012004442386](/Users/sky/Library/Application Support/typora-user-images/image-20211012004442386.png)</p>
<p>1）<code>A</code> 网站提供一个链接，用户点击后就会跳转到 <code>B</code> 网站，授权用户数据给 <code>A</code> 网站使用；</p>
<pre><code class="bash">https://b.com/oauth/authorize?

  response_type=code&amp;

  client_id=CLIENT_ID&amp;

  redirect_uri=CALLBACK_URL&amp;

  scope=read
</code></pre>
<p>上面 <code>URL</code> 中，<code>response_type</code>参数表示要求返回授权码（code），<code>client_id</code>参数让 <code>B</code> 知道是谁在请求，<code>redirect_uri</code>参数是 <code>B</code> 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p>
<p>2）用户跳转后，<code>B</code> 网站会要求用户登录，然后询问是否同意给予 <code>A</code> 网站授权。用户表示同意，这时 <code>B</code> 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p>
<pre><code class="bash">https://a.com/callback?code=AUTHORIZATION_CODE
</code></pre>
<p>上面 <code>URL</code> 中，<code>code</code>参数就是授权码。</p>
<p>3）<code>A</code> 网站拿到授权码以后，就可以在后端，向 <code>B</code> 网站请求令牌。</p>
<pre><code class="bash">https://b.com/oauth/token?

 client_id=CLIENT_ID&amp;

 client_secret=CLIENT_SECRET&amp;

 grant_type=authorization_code&amp;

 code=AUTHORIZATION_CODE&amp;

 redirect_uri=CALLBACK_URL
</code></pre>
<p>上面 <code>URL</code> 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 <code>B</code> 确认 <code>A</code> 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p>
<p>4）<code>B</code> 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 <code>JSON</code> 数据。</p>
<pre><code class="bash">&#123;    

  &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,

  &quot;token_type&quot;:&quot;bearer&quot;,

  &quot;expires_in&quot;:2592000,

  &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,

  &quot;scope&quot;:&quot;read&quot;,

  &quot;uid&quot;:100101,

  &quot;info&quot;:&#123;...&#125;

&#125;
</code></pre>
<p>上面 <code>JSON</code> 数据中，<code>access_token</code>字段就是令牌，<code>A</code> 网站在后端拿到了。</p>
<h4 id="隐藏式"><a href="#隐藏式" class="headerlink" title="隐藏式"></a>隐藏式</h4><p>有些<code>web</code>应用是纯前端应用，没有后端。隐藏式允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为“授权码隐藏式(<code>implicit</code>)”</p>
<p>![image-20211012004534600](/Users/sky/Library/Application Support/typora-user-images/image-20211012004534600.png)</p>
<p>这种方式把<strong>令牌直接传给前端</strong>，是<strong>很不安全</strong>的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p>
<ol>
<li><code>A</code>网站提供一个链接，要求用户跳转到<code>B</code>网站，授权用户数据<code>A</code>网站使用；</li>
</ol>
<pre><code class="bash">https://b.com/oauth/authorize?

  response_type=token&amp;

  client_id=CLIENT_ID&amp;

  redirect_uri=CALLBACK_URL&amp;

  scope=read
</code></pre>
<p>上面<code>url</code>中<code>reponse_type</code>为<code>token</code>，表明要求<code>B</code>网站直接返回令牌(<code>access_token</code>)；</p>
<ol start="2">
<li>用户跳转到<code>B</code>网站，登录后同意予以授权给<code>A</code>网站。这时，<code>B</code>网站会跳回<code>redirect_url</code>参数指定的跳转网址，并且把令牌作为<code>url</code>参数，传给<code>A</code>网站；</li>
</ol>
<pre><code class="bash">https://a.com/callback#token=ACCESS_TOKEN
</code></pre>
<p>上面url中，<code>token</code>参数就是令牌，<code>A</code>网站因此直接在前端拿到令牌。</p>
<p>注意，令牌的位置是 <code>URL</code> 锚点（<code>fragment</code>），而不是查询字符串（<code>querystring</code>），这是因为 <code>OAuth 2.0</code> 允许跳转网址是 <code>HTTP</code> 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p>
<h4 id="密码式"><a href="#密码式" class="headerlink" title="密码式"></a>密码式</h4><p>如果你高度信任某个第三方应用，<code>RFC 6749</code> 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</p>
<p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p>
<p>1）A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌；</p>
<pre><code class="bash">https://oauth.b.com/token?

  grant_type=password&amp;

  username=USERNAME&amp;

  password=PASSWORD&amp;

  client_id=CLIENT_ID
</code></pre>
<p>上面 <code>URL</code> 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 <code>B</code> 的用户名和密码。</p>
<p>2）<code>B</code> 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 <code>JSON</code> 数据里面，作为 <code>HTTP</code> 回应，<code>A</code> 因此拿到令牌。</p>
<h4 id="凭证式"><a href="#凭证式" class="headerlink" title="凭证式"></a>凭证式</h4><p>适用于没有前端的应用，即在命令行下请求令牌。</p>
<p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p>
<p>1）A应用在命令行向B应用发出请求；</p>
<pre><code class="bash">https://oauth.b.com/token?

  grant_type=client_credentials&amp;

  client_id=CLIENT_ID&amp;

  client_secret=CLIENT_SECRET

</code></pre>
<p>上面 <code>URL</code> 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 <code>B</code> 确认 <code>A</code> 的身份。</p>
<p>2）B网站验证通过后，直接返回令牌。</p>
<hr>
<h3 id="令牌的使用"><a href="#令牌的使用" class="headerlink" title="令牌的使用"></a>令牌的使用</h3><p><code>A</code> 网站拿到令牌以后，就可以向 <code>B</code> 网站的 <code>API</code> 请求数据了。</p>
<p><strong>此时，每个发到 <code>API</code> 的请求，都必须带有令牌</strong>。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。</p>
<pre><code class="bash">curl -H &quot;Authorization: Bearer ACCESS_TOKEN&quot; \

&quot;https://api.b.com&quot;
</code></pre>
<p>上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p>
<h3 id="令牌的更新机制"><a href="#令牌的更新机制" class="headerlink" title="令牌的更新机制"></a>令牌的更新机制</h3><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。<code>OAuth 2.0</code> 允许用户自动更新令牌。</p>
<p>具体方法是，**<code>B</code> 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）**。令牌到期前，第三方应用在后台使用 <code>refresh token</code> 发一个请求，去更新令牌。</p>
<pre><code class="bash">https://b.com/oauth/token?

  grant_type=refresh_token&amp;

  client_id=CLIENT_ID&amp;

  client_secret=CLIENT_SECRET&amp;

  refresh_token=REFRESH_TOKEN
</code></pre>
<p>上面 <code>URL</code> 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p>
<p><code>B</code> 网站验证通过以后，就会颁发新的令牌。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>OAuth2.0涉及到3个角色：资源拥有者、资源服务器、第三方应用，核心就是向第三方应用颁发access_token令牌;</p>
</li>
<li><p>令牌与密码的作用是一样的，都可以进入系统，令牌的好处在于更加安全和灵活，主要表现在：</p>
<p>1）令牌是短期的，过期会失效；</p>
<p>2）令牌可以被数据所有者随时撤销；</p>
<p>3）令牌有权限范围(scope)，相对密码，权限控制更精细化。</p>
</li>
<li><p>授权码方式获取令牌是互联网下绝大多数应用使用的一种方式，特点是<code>code</code>码(临时票据)在前端获取，令牌在后端获取，更加安全；</p>
</li>
<li><p>要了解 <code>OAuth2.0</code> 授权登录登录的安全性，首先要明白以下几个关键术语，或者说 <code>OAuth2.0</code> 的安全性体现在：</p>
<p>1）授权作用域 <code>scope</code>。<code>OAuth2.0</code> 授权登录支持授权作用域，第三方应用只能访问授权作用域内的接口</p>
<p>2）授权临时票据 <code>code</code>。<code>OAuth2.0</code> 授权登录的授权临时票据 <code>code</code> 单次有效，一旦换取接口访问凭证成功即失效，防止可能被恶意重复利用；</p>
<p>3）接口访问凭证 <code>access_token</code>。 通过用户授权的授权临时票据 <code>code</code> 换取的接口访问凭证 <code>access_token</code>，有时效性(一般2小时)和作用域(只能访问用户授权范围内的用户数据)。</p>
</li>
</ul>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="scope授权作用域"><a href="#scope授权作用域" class="headerlink" title="scope授权作用域"></a><code>scope</code>授权作用域</h4><p><code>scope</code> 是授权作用域，表示用户授权给第三方的接口权限，通常不同的作用域对应不同的接口权限来获取用户的信息。微信手Q业务部的微信登录使用的<code>scope</code> 是 <code>snsapi_base</code>，也即是我们通常所说的<strong>静默授权</strong>。静默授权可以让移动端网页授权绕过跳转授权登录页请求用户授权的动作，直接跳转第三方网页带上授权临时票据<code>code</code>，但会使得用户已授权作用域（<code>scope</code>）仅为<code>snsapi_base</code>。</p>
<p>如下为 <code>WQ</code> 微信登录的授权作用域相关代码</p>
<pre><code class="cpp">...

// 获取用户授权作用域，优先取前端传递，未传递情况下为`snsapi_base`静默授权

rParams.GetVal(&quot;scope&quot;, m_sScope);

if (m_sScope.empty() || isInValidAppId(m_sScope))

&#123;

m_sScope = &quot;snsapi_base&quot;;

&#125;

...

strOutHtml &lt;&lt; &quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&quot;  

​           &lt;&lt; m_sAppId

​           &lt;&lt; &quot;&amp;redirect_uri=&quot;  

​           &lt;&lt; m_strHttpUrl

​           &lt;&lt; &quot;wxv3/LoginRedirect&amp;response_type=code&amp;scope=&quot;

​           &lt;&lt; m_sScope

​           &lt;&lt; &quot;&amp;state=&quot;

​           &lt;&lt; m_strMonitor

​           &lt;&lt; &quot;#wechat_redirect&quot;;

strUrl = strOutHtml.str();

rCntl.SetResult(302);

rCntl.SetLocation(strUrl.c_str());
</code></pre>
<p><img src="evernotecid://182EBBDA-58B1-4D0E-8473-358C52270E1E/appyinxiangcom/10870108/ENResource/p939" alt="ec2efdc52056c3d2ba05f0aaf37f584d.png"></p>
<h4 id="授权临时票据-code"><a href="#授权临时票据-code" class="headerlink" title="授权临时票据 code"></a>授权临时票据 <code>code</code></h4><p>用户授权之后，资源服务器会返回给第三方应用一个唯一的 <code>code</code>， 这个 <code>code</code> 称之为 <code>授权临时票据</code>， 用于在第三方应用后台换取<code>access_token</code> 令牌。<code>code</code> 的超时时间为 <code>10</code> 分钟，一个 <code>code</code> 只能成功换取一次<code>access_token</code>即失效。<code>code</code> 的<strong>临时性</strong>和<strong>一次性</strong>保障了微信授权登录的安全性。第三方可通过使用 <code>https</code> 和 <code>state</code> 参数，进一步加强自身授权登录的安全性。具体可以参考<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html">微信开放平台FAQ一节</a>的描述。</p>
<h4 id="接口调用凭证-access-token"><a href="#接口调用凭证-access-token" class="headerlink" title="接口调用凭证 access_token"></a>接口调用凭证 <code>access_token</code></h4><p>注意区分 <code>微信开放平台的 access_token</code> 和 <code>微信公众号的 access_token</code>。比如同样是获取用户基本信息，有以下两个接口：</p>
<ul>
<li><p>微信公众号：<code>https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</code></p>
</li>
<li><p>微信开放平台：<code>https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN</code></p>
</li>
</ul>
<p>微信公众号的获取用户接口(我们通常称之为 <code>cgi-bin</code> 类族接口)访问的是公众号自己的资源信息，不需要用户授权。这里所说的公众号自己的资源，是指用户关注公众号以后，和用户相关的一些接口的访问就相当于是访问公众号自己的资源了，比如获取用户基本信息(昵称、头像、性别等)、推送公众号消息等。接口都能调用，只是如果用户没有关注公众号，则接口功能不能实现，比如：获取用户基本信息接口只能返回用户是否关注字段，公众号消息接口推送不出去报未关注等。 我们姑且称之为 公众号级的 <code>access_token</code> 访问令牌。</p>
<p>微信开放平台的获取用户接口(我们通常称之为 <code>sns</code> 类族接口)，这类接口的访问，是第三方应用访问外部用户的资源，需要用户授权得到访问令牌<code>access_token</code> 后才能访问授权作用域 <code>scope</code> 里对应的接口，我这里姑且称之为 用户级的 <code>access_token</code> 授权访问令牌。</p>
<p>综上，<code>微信开放平台的 access_token</code> 为用户授权第三方应用发起接口调用的凭证，<code>微信公众号的 access_token</code> 为访问公众号粉丝相关接口的调用凭证。</p>
<p><strong>参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/doc/483552123f44973079500c2e6d09a18e">微信 cgi-bin 和sns目录下的接口什么区别啊？</a></p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html">微信官方文档.公众号.开始开发.获取access_token</a></p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/User_Management/Get_users_basic_information_UnionID.html#UinonId">微信官方文档.公众号.用户管理.获取用户基本信息(UnionID机制)</a></p>
<h4 id="refresh-token"><a href="#refresh-token" class="headerlink" title="refresh_token"></a><code>refresh_token</code></h4><p>通过授权临时票据 <code>code</code> 获取 接口调用凭证 <code>access_token</code> 的同时，也会返回另外2个关键字段 <code>openid</code> 和 <code>refresh_token</code>。为了安全考虑(非正常的获取)，接口调用凭证 <code>access_token</code> 一般都会有一个比较短的有效期，微信这里是 <code>2</code> 个小时(<code>7200s</code>)。</p>
<p>对于正常获取的接口调用凭证 <code>access_token</code> 来说，<code>2</code>个小时的有效期是比较短的，意味着<code>2</code>个小时后需要用户再次授权，体验上不是很好。因此微信提供了另外一种机制用来延长 <code>access_token</code> 的有效期，这个延长操作只能由应用的所有者来进行，因此我们看到微信提供的延长<code>access_token</code> 有效期的接口需要传递应用id <code>appid</code> 和 应用密钥 <code>appsecretkey</code> (只有应用的管理员才能在开放平台后台查看)。</p>
<p><code>refresh_token</code> 可视为用户授权第三方应用的长效凭证，泄漏等价于<code>access_token</code>的泄漏。微信场景下 <code>refresh_token</code> 最长有效期为 <code>30</code> 天。也就说用户一次授权之后最长需要30天后再次授权。</p>
<p><strong>参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html">微信官方文档.开放平台.网站应用.刷新access_token有效期</a></p>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><h4 id="WQ-的-公众号接口-access-token-是如何维护的？如果是你做，你会怎么维护？"><a href="#WQ-的-公众号接口-access-token-是如何维护的？如果是你做，你会怎么维护？" class="headerlink" title="WQ 的 公众号接口 access_token 是如何维护的？如果是你做，你会怎么维护？"></a><code>WQ</code> 的 公众号接口 <code>access_token</code> 是如何维护的？如果是你做，你会怎么维护？</h4><h4 id="计平的微信登录态校验-openid-和-openkey-调用的是微信开放平台提供的校验接口调用凭证是否有效的接口？"><a href="#计平的微信登录态校验-openid-和-openkey-调用的是微信开放平台提供的校验接口调用凭证是否有效的接口？" class="headerlink" title="计平的微信登录态校验 openid 和 openkey 调用的是微信开放平台提供的校验接口调用凭证是否有效的接口？"></a>计平的微信登录态校验 <code>openid</code> 和 <code>openkey</code> 调用的是微信开放平台提供的校验接口调用凭证是否有效的接口？</h4><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0 的一个简单解释</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">OAuth 2.0 的四种方式</a></p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html">网站应用微信登录开发指南</a></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/10/12/hello-world/" rel="prev" title="Hello World">
                  <i class="fa fa-chevron-left"></i> Hello World
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
